데이터 중심 애플리케이션 설계 

지은이 : 마틴 클레프만 
옮긴이 : 정재부, 김영준, 이도경 
출판일 : 2021년 10월 20일 

Part 1. 데이터 시스템의 기초

 1장. 신뢰할 수 있고 확장 가능하며 유지보수하기 쉬운 애플리케이션
  
  1. 데이터 시스템에 대한 생각

  2. 신뢰성
   2.1. 하드웨어 결함
   2.2. 소프트웨어 오류
   2.3. 인적 오류
   2.4. 신뢰성은 얼마나 중요할까 ?

  3. 확장성
   3.1. 부하 기술하기
   3.2. 성능 기술하기
   3.3. 부하 대응 접근 방식 

  4. 유지보수성
   4.1. 운용성 : 운영의 편리함 만들기
   4.2. 단순성 : 복잡도 관리
   4.3. 발전성 : 변화를 쉽게 만들기 

  5. 정리 


 2장. 데이터 모델과 질의 언어
  
  1. 관계형 모델과 문서 모델 
   1.1. NoSQL의 탄생
   1.2. 객체 관계형 불일치 
   1.3. 다대일과 다대다 관계
   1.4. 문서 데이터베이스는 역사를 반복하고 있나?
   1.5. 관계형 데이터베이스와 오늘날의 문서 데이터베이스

  2. 데이터를 위한 질의 언어 
   2.1. 웹에서의 선언형 질의
   2.2. 맵리듀스 질의 

  3. 그래프형 데이터 모델 
   3.1. 속성 그래프
   3.2. 사이퍼 질의 언어
   3.3. SQL의 그래프 질의
   3.4. 트리플 저장소와 스파클
   3.5. 초석: 데이터 로그

  4. 정리


 3장. 저장소와 검색 
  1. 데이터베이스를 강력하게 만드는 데이터 구조
   1.1.  해시 색인
   1.2. SS 테이블과 LSM 트리
   1.3. B 트리
   1.4. B 트리와 LSM 트리 비교
   1.5. 기타 색인 구조

  2. 트랜잭션 처리나 분석?
   2.1. 데이터 웨어하우징
   2.2. 분석용 스키마 : 별 모양 스키마와 눈꽃송이 모양 스키마

  3. 칼럼 지향 저장소
   3.1. 칼럼 압축
   3.2. 칼럼 저장소의 순서 정렬
   3.3. 칼럼 지향 저장소에 쓰기
   3.4. 집계 : 데이터 큐브와 구체화 뷰

  4. 정리


 4장. 부호화의 발전
  1. 데이터 부호화 형식
   1.1. 언어별 형식
   1.2. JSON, XML, 이진 변형 
   1.3. 스트리프트와 프로토콜 버퍼 
   1.4. 아브로
   1.5. 스키마의 장점

  2. 데이터플로 모드
   2.1. 데이터베이스를 통한 데이터플로
   2.2. 서비스를 통한 데이터플로 : REST와 RPC
   2.3. 메시지 전달 데이터플로 

  3. 정리



Part2. 분산 데이터 

 ● 고부하로 확장 
 - 비공유 아키텍쳐
 - 복제 대 파티셔닝

 5장. 복제
  1. 리더와 팔로워
   1.1. 동기식 대 비동기식 복제
   1.2. 새로운 팔로워 설정
   1.3. 노드 중단 처리
   1.4. 복제 로그 구현

  2. 복제 지연 문제
   2.1. 자신이 쓴 내용 읽기
   2.2. 단조 읽기
   2.3. 일관된 순서로 읽기
   2.4. 복제 지연을 위한 해결책

  3. 다중 리더 복제
   3.1. 다중 리더 복제의 사용 사례
   3.2. 쓰기 충돌 다루기
   3.3. 다중 리더 복제 토폴로지

  4. 리더 없는 복제
   4.1 노드가 다운됐을 때 데이터베이스에 쓰기
   4.2 정족수 일관성의 한계
   4.3 느슨한 정족수와 암시된 핸드오프
   4.4 동시 쓰기 감지 

  5. 정리 


 6장. 파티셔닝 
  1. 파티셔닝과 복제

  2. 키-값 데이터 파티셔닝
   2.1 키 범위 기준 파티셔닝
   2.2 키의 해시값 기준 파티셔닝
   2.3 쏠린 작업부하와 핫스팟 완화

  3. 파티셔닝과 보조 색인
   3.1 문서 기준 보조 색인 파티셔닝
   3.2 용어 기준 보조 색인 파티셔닝

  4. 파티션 재균형화
   4.1 재균형화 전략
   4.2 운영: 자동 재균형화와 수동 재균형화

  5. 요청 라우팅
   5.1 병렬 질의 실행

  6. 정리


 7장. 트랜잭션
  1. 애매모호한 트랜잭션의 개념
   1.1 ACID의 의미
   1.2 단일 객체 연산과 다중 객체 연산
  
  2. 완화된 격리 수준
   2.1 커밋 후 읽기
   2.2 스냅숏 격리와 반복 읽기
   2.3 갱신 손질 방지
   2.4 쓰기 스큐와 팬텀

  3. 직렬성
   3.1 실제적인 직렬 실행
   3.2 2단계 잠금(2PL)
   3.3 직렬성 스냅숏 격리(SSI)

  4. 정리


 8장. 분산 시스템의 골칫거리
  1. 결함과 부분 장애
   1.1 클라우드 컴퓨팅과 슈퍼컴퓨팅

  2. 신뢰성 없는 네트워크
   2.1 현실의 네트워크 결함
   2.2 결함 감지
   2.3 타임아웃과 기약 없는 지연
   2.4 동기 네트워크 대 비동기 네트워크

  3. 신뢰성 없는 시계
   3.1 단조 시계 대 일 기준 시계
   3.2 시계 동기화와 정확도
   3.3 동기화된 시계에 의존하기
   3.4 프로세스 중단

  4. 지식, 진실, 그리고 거짓말
   4.1 진실은 다수결로 결정된다.
   4.2 비잔틴 결함
   4.3 시스템 모델과 현실

  5. 정리


 9장 일관성과 합의
  1. 일관성 보장

  2. 선형성
   2.1 시스템에 선형성을 부여하는 것은 무엇인가?
   2.2 선형성에 기대기
   2.3 선형성 시스템 구현하기
   2.4 선형성의 비용

  3. 순서화 보장
   3.1 순서화와 인과성
   3.2 일련번호 순서화
   3.3 전체 순서 브로드캐스트

  4. 분산 트랜잭션과 합의
   4.1 원자적 커밋과 2단계 커밋(2PC)
   4.2 현실의 분산 트랜잭션
   4.3 내결함성을 지닌 합의
   4.4 맴버십과 코디네이션 서비스 

  5. 정리


Part